# TICG-chromatin

Theoretically Informed Coarse Grain (TICG) model applied to chromatin organization. 

General overview: 

The base TICG engine (locaed in /src) is written in C++.

A Python wrapper (located in /pylib) is the primary API for instantiating, dispatching, and analyzing simulations. A user should only need to familiarize themselves with the python library in order to use this simulation software. Higher level functionality is also available for conducting iterative simulations using maximum entropy optimization to parameterize epigenetic interactions in order to match experimental Hi-C conformation capture data.


## python implementation
a python wrapper for the TICG engine is packaged in pylib (temporary name).
the library includes classes for running individual simulations, maxent optimization, and data pipelines

## installation:
to build the engine (C++ extension) from source and install the python package (required first time)
```
make all
```

to install just the python package (C++ extension must have been built at least once)
```
make install
```

## Documentation
to build the docs:
```
make docs
```
after building, they are located in pylib/docs/build/index.html, and can be opened in a web browser

## General Structure

The core TICG simulation engine is written in C++ (located in src).
Pybind is used to extend the engine as a python module (ticg).

further modules are built on top of the engine both individual simulations and maxent optimizations:

Simulations:
- pyticg (low level), just the bare engine
- pysim	 (high level), wrapper around pyticg for manipulating simulations and their settings

Maxent Optimizations:
- maxent (low level), just the optimizer and dispacher for iterative simulations
- pipeline (high level), wrapper around maxent for manipulating maxent runs and their settings

The following is a general description of the individual modules:

### pyticg module
this is the lowest-level wrapper around the engine, generated by pybind and packaged as a C++ extension.
Users should typically not need to interface with this module.
The wrapper exposes only a single class, with the following pseudocode interface:
``` python
class Sim:
	__init__():
		# default initializer: outputs simulation data to a directory called "data_out", and logs to stdout
	
	__init__(output_file):
		# custom initializer: outputs simulation data to output_file, and logs to output_file/log.log

	def run():
		# execute simulation
```

### pysim module
this module implements the pysim class, a wrapper around the pyticg engine with much more functionality. 
This class is the main interface to the user performing simulations. 

#### usage:
to set up a simulation, all that is needed are polymer sequences and a config file.
the config file contains physical constants (number of beads)  and parameters for the 
monte carlo simulation (number of sweeps, etc). A default config file is available in maxent/defaults/config.json
```python
from pylib.pysim import Pysim

# load config, sequences ... 

sim = Pysim(root="output_goes_here", config, sequences)

# run simulation with parameters defined in config
sim.run()

# or, run equililbration followed by production. optionally, production can be parallelized
sim.run_eq(equilibration_sweeps, production_sweeps, parallel_simulations)
```
a variation of this is shown in examples/single-simulation

pysim objects can also be constructed from directories containing the required data. This is often 
useful if the results of a previous simulation need to be reproduced, or extended
``` python
sim = Pysim.from_directory("output_directory_from_previous_sim")

# tweak config
sim.config["nSweeps"] = larger_number_than_last_time
sim.run("reproduce")
```
a code snippet exists at /examples/snippets/simulate_current_directory.py and can be run from the command
line while in the directory of choice


### maxent module
the maxent module is a low-level interface for executing maximum entropy optimization runs for genome folding.
the class implements the minimal interface necessary for maximum entropy optimization (iteratively setting up 
pysim simulations and calling an optimizer to advance between iterations).

It does not implement methods involving processing data, determining maxent optimizer goals 
from experimental data, or deriving polymer sequences. These are provided as inputs to the maxent instance, and
as such the maxent module is regarded as "low level" in the context of maximum entropy optimization features. These 
features are implemented in the higher-level pipeline module

#### usage:
maxent optimization parameters (number of iterations, initial state, etc) are specified in params. 
a default parameter file is available in maxent/defaults/params.json
```python
# load maxent parameters, simulation config, polymer sequences, and ground truth hic ...

me = Maxent(root="output_goes_here", params, config, sequences, gthic)
me.fit()
```
a variation of this is shown in examples/chipseq_maxent, although it loads from data files 
not included in the github repo, so it won't work right out of the box.

similarly to pysim objects, maxent objects can also be constructed from directories. This is often 
useful if an already finished or prematurely killed maxent run needs to be extened for further iterations.
```python

me = Maxent.from_directory(original_directory)
me.set_root(new_output_directory) # so as not to overwrite
me.fit()
```
a code snippet of exists at /examples/snippets/load_maxent

### pipeline module
this module provides a high-level interface for executing maximum entropy optimization runs for genome folding.
it can be viewed as a wrapper around a maxent instance, combined with methods that derive all necessary
inputs to the maxent procedure (polymer sequences, physical observables used as maxent goals). This is also frequently
useful when sweeping over a parameter value.

a callable can be supplied, which calculates sequences from an experimental contactmap.
```python
# sweep over the number of sequences k and optimize for each
for k in range(10):
	seqs_method = functools.partial(ep.get_sequences, k=k)
	pipe = Pipeline(name, gthic, config, params, seqs_method=seqs_method, load_first=False)
	pipe.fit()
```
a variation of this is shown in examples/sweep_pcs


	




