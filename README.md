#TICG-chromatin


## python implementation
a python wrapper for the TICG engine is packaged in pylib (temporary name).
the library includes classes for running individual simulations, maxent optimization, and data pipelines

## installation:
to build the engine (C++ extension) from source and install the python package (required first time)
```
make all
```

to install just the python package (C++ extension must have been built at least once)
```
make install
```

## Documentation
to build the docs:
```
make docs
```
after building, they are located in pylib/docs/build/index.html, and can be opened in a web browser

## General Structure

The simulation engine is written in C++ (located in src)
A python wrapper available which includes the engine as an extension (located in pylib)

The following is a rough description of the pylib package structure:

### pyticg module
this is the lowest-level wrapper around the engine, generated by pybind and packaged as a C++ extension.
Users should typically not need to interface with this module.
The wrapper exposes only a single class, with the following pseudocode interface:
``` python
class Sim:
	__init__():
		# default initializer: outputs simulation data to a directory called "data_out", and logs to stdout
	
	__init__(output_file):
		# custom initializer: outputs simulation data to output_file, and logs to output_file/log.log

	def run():
		# execute simulation
```

### pysim module
this module implements the pysim class, a wrapper around the pyticg engine with much more functionality. 
This class is the main interface to the user performing simulations. 

#### pysim usage:
to set up a simulation, all that is needed are polymer sequences, and a config file.
the config file contains physical constants (number of beads)  and parameters for the 
monte carlo simulation (number of sweeps, etc)
a default config file is available in maxent/defaults/config.json
```python
from pylib.pysim import Pysim

# load config, sequences ... 

sim = Pysim(root="output_goes_here", config, sequences)

# run simulation with parameters defined in config
sim.run()

# or, run equililbration followed by production. optionally, production can be parallelized
sim.run_eq(equilibration_sweeps, production_sweeps, parallel_simulations)
```
a variation of this is shown in examples/single-simulation

pysim objects can also be constructed from directories containing the required data. This is often 
useful if the results of a previous simulation need to be reproduced, or extended
``` python
sim = Pysim.from_directory("output_directory_from_previous_sim")

# tweak config
sim.config["nSweeps"] = larger_number_than_last_time
sim.run("reproduce")
```
a code snippet exists at /examples/snippets/simulate_current_directory.py and can be run from the command
line while in the directory of choice


### maxent module
the maxent module is a low-level interface for executing maximum entropy optimization runs for genome folding.
the class implements the minimal interface necessary for maximum entropy optimization (iteratively setting up 
pysim simulations and calling an optimizer to advance between iterations).

It does not implement methods involving processing data, determining maxent optimizer goals 
from experimental data, or deriving polymer sequences. These are provided as inputs to the maxent instance, and
as such the maxent module is regarded as "low level" in the context of maximum entropy optimization features. 
Higher level features are exposed through the pipeline module

#### maxent usage:
maxent optimization parameters (number of iterations, initial state, etc) are specified in params. 
a default parameter file is available in maxent/defaults/params.json
```python
# load maxent parameters, simulation config, polymer sequences, and ground truth hic ...

me = Maxent(root="output_goes_here", params, config, sequences, gthic)
me.fit()
```

### pipeline module
this module provides a high-level interface for executing maximum entropy optimization runs for genome folding.
it can be viewed as a wrapper around a maxent instance, combined with methods that derive all necessary
inputs to the maxent procedure (polymer sequences, physical observables used as maxent goals).



